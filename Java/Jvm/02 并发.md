# 并发

[TOC]

## 一、Java内存模型与线程

### 1. Java内存模型

#### 1.1 基本概念

>  java内存模型定义了程序中各种变量的访问规则。

> 变量包含了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，也就不会有线程安全问题。

1. 所有的变量都存储在主内存，每个线程都有各自的工作内存，线程中的工作内存保存了该线程使用的**变量的副本**。
2. 线程对变量的所有操作都必须在工作内存中，不能直接读写主内存。
3. 不同线程之间的变量**无法相互访问**，线程间变量值的传递均需通过主存来完成。

![1678591846756](images/1678591846756.png)



#### 1.2 volatile变量

volatile修饰的变量具有：

1. **可见性，对所有线程可见。**
   * 当一条线程修改了一个变量的值，新值对于其他线程是立即可以知道的。普通变量的值在线程间传递时需要通过主内存来完成。
   * 举例：线程A修改一个普通变量值，向主内存进行回写，线程B在写完后对主内存进行读取，这个变量才会对线程B可见。
2. **禁止指令重排优化。**

volatile变量只能保证可见性，所以不符合以下两个规则场景都需要**加锁（synchronized、java.util.concurrent中的锁或原子类）**来保证原子性：

1. 运算结果不依赖变量的当前值，或者单一线程修改变量值。
2. 变量不需要与其他状态变量共同参与不变约束。

```java
// 使用场景举例(可见性)：
// 当shutdown()方法被调用时，能保证所有的doWork()方法都立即停下来。
volatile boolean shutdownRequested;

public void shutdown(){
    shutdownRequested = true;
}

public void doWork(){
    while(!shutdownRequested){
        // 业务逻辑
    }
}
```

volatile的实现：

1. 在volatile修饰的变量，赋值前后多执行了一个“lock addl$0x0，(%esp)” 操作，这个操作相当于一个内存屏障（**指令重排时不能把后面的指令重排序到内存屏障之前的位置**）。

   > 指令重排不是乱排序，一定是在保证程序最终结果正确的情况下对执行顺序的优化。排序后，在同一个处理器中，重排序的代码依旧是有序的。

2. **加入空操作**，将本处理器的缓存写入内存，该写入动作也会引起别的处理器或者别的内核**无效化其缓存**。这种操作相当于对缓存中的变量做了一次“store(存储)和write(写入)”操作。通过这样的空操作，就可以让volatile变量的修改对其他处理器立即可见。



**ps： long和double的非原子性协定**

Java内存模型要求lock、unlock、read、load、assign、use、store、write这八种操作都具有原子性。

long和double的非原子性协定：long和double是64位数据类型，允许虚拟机讲没有被volatile修饰的64位数据的读写分为两次32位操作。

如果多个线程共享一个未被volatile修饰的long或者double的变量。这种情况下就会导致读取到的既不是原值，也不是“半个变量”的数值。因为现代处理器一般都有专门处理的浮点运算器，一般不考虑这种问题。如果有可以加上volatile修饰。



#### 1.3 原子性，可见性和有序性

1. **原子性**

   由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个。

   synchronized块之间的操作也具备原子性。

2. **可见性**

   volatile，synchronized和final。

   synchronized代码块：对一个变量执行unlock操作前，必须把此变量同步回主内存中(store, write)。

   final：final的可见性指的是被final修饰的字段在构造器中一旦被初始化完成，并且没有this逃逸（未初始化就被引用出去），那么其他线程就可以看见final字段的值。

   ```java
   // final可见性
   public static final int i; 
   public final int j; 
   static { 
       i = 0; 
       // 省略后续动作 
   }
   { 
       // 也可以选择在构造函数中初始化 
       j = 0; 
       // 省略后续动作
   }
   ```

   

3. **有序性**

   如果再本线程内观察，所有操作都是有序的，如果在一个线程观察另一个线程，所有操作都是无序的。

   前半句指：**线程内似串行**，后半句指：**指令重排**和**工作内存与主内存同步延迟**。

   synchronized可以解决所有并发问题。



#### 1.4 先行发生原则

> ”先行发生“原则是java内存模型定义的两项操作之间的顺序关系，比如操作A先行发生于操作B，其实就是在发生操作B之前，操作A产生的影响能被操作B观察到。

以下是java内存模型定义的先行发生关系：

程序次序规则，管理锁定规则，volatile变量规则，线程启动规则，线程终止规则，线程中断规则，对象终结规则，传递性。



### 2. Java与线程



## 二、线程安全与锁优化

### 1. 线程安全

#### 1.1 Java中的线程安全

1. 不可变

   final关键字修饰的基本数据类型都是不可变的。修饰的对象不能保证。

2. 





































